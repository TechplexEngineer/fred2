// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5122.Fred2.commands;

import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDController.Tolerance;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc5122.Fred2.Robot;
import org.usfirst.frc5122.Fred2.U;

/**
 *
 */
public class a_drive_turn_angle1 extends Command {
	public static final double kDefaultPeriod = .05;
	private static int instances = 0;
	private double m_P; // factor for "proportional" control
	private double m_I; // factor for "integral" control
	private double m_D; // factor for "derivative" control
	private double m_F; // factor for feedforward term
	private double m_maximumOutput = 1.0; // |maximum output|
	private double m_minimumOutput = -1.0; // |minimum output|
	private double m_maximumInput = 0.0; // maximum input - limit setpoint to
											// this
	private double m_minimumInput = 0.0; // minimum input - limit setpoint to
											// this
	// private boolean m_continuous = false; // do the endpoints wrap around?
	// eg. Absolute encoder
	// private boolean m_enabled = false; //is the pid controller enabled
	private double m_prevError = 0.0; // the prior sensor input (used to compute
										// velocity)
	private double m_totalError = 0.0; // the sum of the errors for use in the
										// integral calc
	// private Tolerance m_tolerance; //the tolerance object used to check if on
	// target
	private double m_setpoint = 0.0;
	private double m_error = 0.0;
	private double m_result = 0.0;
	private double m_prevResult = 0.0;
	private double m_max = 0;
	private boolean m_rampUp = false;
	private double m_prevdterm = 0.0;

	public a_drive_turn_angle1(double turn, double kp, double ki, double kd, double max, boolean rampUp) {
		this.m_P = kp;
		this.m_I = ki;
		this.m_D = kd;
		this.m_setpoint = turn;
		this.m_max = max;
		this.m_rampUp = rampUp;

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.drive.resetGyro();
		m_error = 0;
		m_prevError = 0;
        m_totalError = 0;
        m_result = 0;
        m_prevdterm = 0;
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {

		double input = Robot.drive.getGyroAngle();
		double dterm = 0;
		
		
		m_error = m_setpoint - input;

		if (m_I != 0) {
			double potentialIGain = (m_totalError + m_error) * m_I;
			if (potentialIGain < m_maximumOutput) {
				if (potentialIGain > m_minimumOutput) {
					m_totalError += m_error;
				} else {
					m_totalError = m_minimumOutput / m_I;
				}
			} else {
				m_totalError = m_maximumOutput / m_I;
			}
		}
		//try to eliminate high frequency noise
		dterm = .1 * (m_error - m_prevError) + .9 * m_prevdterm;
		m_prevdterm = dterm;

		m_result = m_P * m_error + m_I * m_totalError + m_D * dterm + m_setpoint * m_F;
		m_prevError = m_error;
		m_prevResult = m_result;

		if (m_result > m_maximumOutput) {
			m_result = m_maximumOutput;
		} else if (m_result < m_minimumOutput) {
			m_result = m_minimumOutput;
		}

		//m_result;
		m_result = U.constrain(-m_max, m_result, m_max);
    	if (Math.abs(m_result) < .4 && m_result != 0) {
    		m_result = (m_result/Math.abs(m_result)) * 0.4;
    	}
    	if (m_rampUp) {
	    	if ((timeSinceInitialized() * 2 + 0.4) < 1) {
	    		m_result = m_result * (timeSinceInitialized() * 2 + 0.4);
	    	}
	    }
        Robot.drive.HDrive(0, m_result, 0);

	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return Math.abs(m_error) < 1.5 && Robot.drive.gyro1.getRate() < 5;
	}

	// Called once after isFinished returns true
	protected void end() {
		 Robot.drive.stop();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}
}
